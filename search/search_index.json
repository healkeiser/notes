{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"","tags":["home"]},{"location":"#notes","title":"Notes","text":"<p>This documentation is built with MkDocs and the MkDocs Publisher plugin, since I'm using Obsidian to take the notes. You can clone the repository and open it as an Obsidian Vault if you prefer reading it locally!</p> <p>Warning</p> <p>Some stuff might get displayed incorrectly in Obsidian, such as HTML tags.</p> <p>Warning</p> <p>You might notice a lot of <code>README.md</code> files, please ignore those - they're here to indicate attributes on directories for MkDocs Publisher.</p> <p>Note</p> <p>If you spot any issue or have any recommendations, don't hesitate to send me an email.</p>","tags":["home"]},{"location":"development/javascript/auto-changelog/","title":"Auto Changelog","text":"<p>How to generate an automatic changelog, for example in a Python package.</p>","tags":["development","javascript","python","package"]},{"location":"development/javascript/auto-changelog/#install","title":"Install","text":"<p>Install <code>auto-changelog</code> using <code>npm</code>.</p> <pre><code>npm install -g auto-changelog\n</code></pre> <p>Create  a <code>package.json</code> file at the root of your package.</p> package.json<pre><code>{\n  \"scripts\": {\n    \"changelog\": \"auto-changelog -p\"\n  }\n}\n</code></pre> <p>Let's now assume you have tagged a new release on Git, you can now run the following command to update the <code>CHANGELOG.md</code> file:</p> <pre><code>npm run changelog\n</code></pre> <p>Since a tag is only bound to a single commit, the changelog won't keep track of the unreleased commits. In order to add those, you can modify <code>package.json</code>:</p> package.json<pre><code>{\n    \"scripts\": {\n        \"changelog\": \"auto-changelog -p --unreleased\"\n    }\n}\n</code></pre>","tags":["development","javascript","python","package"]},{"location":"development/python/distribute-package-to-pypi/","title":"Distribute Package to PyPi","text":"<p>How to distribute a Python package through PyPI.</p>","tags":["development","python","package"]},{"location":"development/python/distribute-package-to-pypi/#setup-package","title":"Setup Package","text":"<p>Create a <code>.pypirc</code> file under <code>%userprofile%</code>. Add your API key from PyPi.</p> .pypirc<pre><code>[distutils]\n  index-servers = pypi\n\n[pypi]\n  repository: https://upload.pypi.org/legacy/\n  username = __token__\n  password = &lt;API KEY&gt;\n</code></pre> <p>Inside your Python package, create a <code>setup.py</code> file at the root. This file is taken from the fxgui package.</p> setup.py<pre><code>\"\"\"PyPI setup script.\"\"\"\n\n# Built-in\nfrom pathlib import Path\nfrom setuptools import setup, find_packages\nimport sys\n\n# Metadata\n__author__ = \"Valentin Beaumont\"\n__email__ = \"valentin.onze@gmail.com\"\n\n\n# Add `README.md` as project long description\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\n# Add required dependencies\ninstall_requires = [\"qtpy\", \"QtAwesome\"]\n\nsetup(\n    name=\"fxgui\",\n    version=\"2.3.1\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    description=\"Custom Python classes and utilities tailored for Qt built UI, in VFX-oriented DCC applications.\",\n    url=\"https://github.com/healkeiser/fxgui\",\n    author=\"Valentin Beaumont\",\n    author_email=\"valentin.onze@gmail.com\",\n    license=\"MIT\",\n    keywords=\"Qt PySide2 VFX DCC UI\",\n    packages=find_packages(),\n    install_requires=install_requires,\n    include_package_data=True,\n)\n</code></pre> <p>Warning</p> <p>The above script works if you plan on manually release the package to PyPI. In the case where you have a GitHub action configured, you need to replace some lines as explained in the Link Package Version to Git Tag section.</p> <p>You can also add a <code>MANIFEST.in</code> file, which specify additional files to include in the source distribution (sdist) that are not automatically included by default.</p> MANIFEST.in<pre><code>recursive-include fxgui *\nglobal-exclude __pycache__/*\n</code></pre>","tags":["development","python","package"]},{"location":"development/python/distribute-package-to-pypi/#distribute-package","title":"Distribute Package","text":"<p>Install <code>twine</code> library</p> <pre><code>python -m pip install twine\n</code></pre> <p>Build package</p> <pre><code>python setup.py sdist bdist_wheel\n</code></pre> <p>Upload package</p> <pre><code>python -m twine upload dist/* --skip-existing\n</code></pre> <p>Build package locally</p> <pre><code>python -m pip install -e .\n</code></pre>","tags":["development","python","package"]},{"location":"development/python/distribute-package-to-pypi/#cicd-with-github-actions","title":"CI/CD With GitHub Actions","text":"<p>Go to GitHub and add two repository secrets:</p> <ul> <li><code>PYPI_USERNAME</code>: Your PyPI username.</li> <li><code>PYPI_PASSWORD</code>: Your PyPI password or API token.</li> </ul> <p>Warning</p> <p>If using an API key, <code>PYPI_USERNAME</code> should be <code>__token__</code>.</p> <p>Inside your local repository, Create a <code>.github/workflows</code> directory, and add a <code>publish.yml</code> inside.</p> publish.yml<pre><code>name: Publish Python Package\n\non:\n  push:\n    tags:\n      - 'v*.*.*'  # Trigger the workflow on version tags\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v2\n\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.x'\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install setuptools wheel twine\n\n    - name: Build package\n      run: |\n        python setup.py sdist bdist_wheel\n\n    - name: Publish package to PyPI\n      env:\n        TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}\n        TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}\n      run: |\n        twine upload dist/*\n</code></pre> <p>You can now tag the release, which will trigger the package release on PyPI.</p> <pre><code>git add .\ngit commit -m \"Initial release\"\ngit tag v1.0.0\ngit push origin v1.0.0\n</code></pre>","tags":["development","python","package"]},{"location":"development/python/distribute-package-to-pypi/#link-package-version-to-git-tag","title":"Link Package Version to Git Tag","text":"<p>You can link the PyPI package version to the Git tag by installing <code>setuptools_scm</code>:</p> <pre><code>python -m pip install setuptools_scm\n</code></pre> <p>And modify your <code>setup.py</code> accordingly:</p> setup.py<pre><code>setup(\n    name=\"fxgui\",\n    use_scm_version=True,\n    setup_requires=[\"setuptools_scm\"],\n    ...\n</code></pre>","tags":["development","python","package"]},{"location":"development/python/multiple-versions-on-windows/","title":"Multiple Versions on Windows","text":"<p>How to manage multiple Python versions on a Windows system.</p>","tags":["development","windows","python"]},{"location":"development/python/multiple-versions-on-windows/#using-pyenv-for-windows","title":"Using Pyenv for Windows","text":"<p>We can manage multiple Python versions on a system using pyenv for Windows, which brings the same capabilities than on an Unix system. See Multiple versions on macOS.</p> <p>List the available Python installations</p> <pre><code>pyenv install --list\n</code></pre> <p>Install a Python version</p> <pre><code>pyenv install 3.9.13\n</code></pre> <p>Set the global Python version</p> <pre><code>pyenv global 3.9.13\n</code></pre> <p>Set the Python version only for the current shell </p> <pre><code>pyenv shell 3.9.13\n</code></pre> <p>Deprecated</p> <p>The following method is deprecated in favor of pyenv.</p>","tags":["development","windows","python"]},{"location":"development/python/multiple-versions-on-windows/#how-to","title":"How-to","text":"<p>We can define some batch scripts in a given directory. In the case we're using Cloud VFX Server, we can rely on <code>$ENVIRONMENT_ROOT</code> (which expand to <code>C:\\Users\\valen\\OneDrive\\.config\\environment</code> in my case).</p> <p>In <code>$ENVIRONMENT_ROOT</code>, create a <code>python</code> folder: <code>C:\\Users\\valen\\OneDrive\\.config\\environment\\python</code>.</p> <p>You can now create a batch script for each version of python you want to use in this folder:</p> <p><code>python39.bat</code></p> <pre><code>@ECHO OFF\nsetlocal\nset \"PYTHONHOME=%LOCALAPPDATA%\\programs\\python\\python39\"\nset \"PYTHONPATH=%PYTHONHOME%\\lib;%PYTHONPATH%\"\n\"%PYTHONHOME%\\python.exe\" %*\nendlocal\n</code></pre> <p>Finally, edit your <code>$PATH</code> environment variable, adding as a first entry the <code>%ENVIRONMENT_ROOT%\\python</code> folder, so the batch files are accessible inside a terminal.</p>","tags":["development","windows","python"]},{"location":"development/python/multiple-versions-on-windows/#pip","title":"Pip","text":"<p>You can now use <code>pip</code> using this method, by typing:</p> <pre><code>python39 -m pip &lt;command&gt;\n</code></pre> <pre><code>python39 -m pip install PySide2\n</code></pre>","tags":["development","windows","python"]},{"location":"development/python/multiple-versions-on-macos/","title":"Multiple Versions on macOS","text":"<p>How to manage multiple Python versions on a macOS system.</p>","tags":["development","macOS","python"]},{"location":"development/python/multiple-versions-on-macos/#how-to","title":"How-to","text":"<p>We'll use the same method as Windows, pyenv. Refer to the Windowsguide.</p> <p>Backlinks:</p>","tags":["development","macOS","python"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/","title":"Custom Schemas","text":"<p>How-to create a USD custom schema.</p> <p>Important Links</p> <ul> <li> <p>USD Survival Guide - Schemas</p> </li> <li> <p>USD - Generating New Schema Classes</p> </li> </ul> <p>Note</p> <p>You can find the usdFxquinox plugin on GitHub.</p> <p>The easiest way to create a custom schema is to create what\u2019s called a codeless schema (uncompiled version). This will create a new schema but won\u2019t provide the C++/Python bindings from the freshly created schema class.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#directory-structure","title":"Directory Structure","text":"<p>Let\u2019s start by creating a directory and a <code>schema.usda</code> file:</p> Directory<pre><code>.\n\u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n    \u2514\u2500\u2500 \ud83d\udcc1 resources/\n        \u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n            \u2514\u2500\u2500 \ud83d\udcc4schema.usda\n</code></pre> <p>Which corresponds to:</p> Directory<pre><code>.\n\u2514\u2500\u2500 \ud83d\udcc1 &lt;plugin name&gt;/\n    \u2514\u2500\u2500 \ud83d\udcc1 resources/\n        \u2514\u2500\u2500 \ud83d\udcc1 &lt;plugin name&gt;/\n            \u2514\u2500\u2500 \ud83d\udcc4 schema.usda\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#edit-schemausda","title":"Edit <code>schema.usda</code>","text":"<p>Let\u2019s now edit our <code>schema.usda</code> file. This will contain the IsA schemas or API schemas you want to create.</p> schema.usda<pre><code>#usda 1.0\n(\n    subLayers = [\n        @usd/schema.usda@\n    ]\n)\n\nover \"GLOBAL\" (\n    customData = {\n        string libraryName       = \"usdFxquinox\"\n        string libraryPath       = \".\"\n        string libraryPrefix     = \"usdFxquinox\"\n        bool skipCodeGeneration = true\n    }\n)\n{\n}\n\nclass FxquinoxContextInfo \"FxquinoxContextInfo\" (\n    doc = \"\"\"Holder for fxquinox-specific context information.\"\"\"\n    inherits = &lt;/Typed&gt;\n    customData = {\n        string className = \"ContextInfo\"\n        }\n    )\n{\n    string fxquinox:project (\n        doc = \"\"\"The project name.\"\"\"\n    )\n\n    asset fxquinox:projectRoot (\n        doc = \"\"\"The project root path.\"\"\"\n    )\n\n    string fxquinox:entity (\n        doc = \"\"\"The current context entity (asset or shot).\"\"\"\n    )\n\n    string fxquinox:assetType (\n        doc = \"\"\"If the entity is an asset, the type of asset.\"\"\"\n    )\n\n    string fxquinox:asset (\n        doc = \"\"\"If the entity is an asset, the asset.\"\"\"\n    )\n\n    string fxquinox:sequence (\n        doc = \"\"\"If the entity is a shot, the sequence.\"\"\"\n    )\n\n    string fxquinox:shot (\n        doc = \"\"\"If the entity is a shot, the shot.\"\"\"\n    )\n\n    string fxquinox:step (\n        doc = \"\"\"The context pipeline step.\"\"\"\n    )\n\n    string fxquinox:task (\n        doc = \"\"\"The context pipeline task.\"\"\"\n    )\n\n    string fxquinox:user (\n        doc = \"\"\"The current username.\"\"\"\n    )\n\n    string fxquinox:hostname (\n        doc = \"\"\"The current hostname (machine name).\"\"\"\n    )\n}\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#run-usdgenschema","title":"Run usdGenSchema","text":"<p>Once you\u2019re happy with your new schema, we now need to run usdGenSchema. The easiest way is to run the one shipping with your DCC compiled USD.</p> <p>I made this batch script to run it on Windows:</p> .run_usdGenSchema.bat<pre><code>@echo off\n\nREM Set paths to Houdini programs, and the USD file\nset HOUDINI_VERSION=20.0.547\nset USD_PLUGIN_NAME=usdFxquinox\nset HYTHON_PATH=\"C:\\Program Files\\Side Effects Software\\Houdini %HOUDINI_VERSION%\\bin\\hython.exe\"\nset USDGENSCHEMA_PATH=\"C:\\Program Files\\Side Effects Software\\Houdini %HOUDINI_VERSION%\\bin\\usdGenSchema\"\nset SCHEMA_PATH=%~dp0%USD_PLUGIN_NAME%\\schema.usda\nset DESTINATION_PATH=%~dp0\n\necho Running usdGenSchema for %USD_PLUGIN_NAME%:\necho           Hython: %HYTHON_PATH%\necho       USD plugin: %USD_PLUGIN_NAME%\necho     UsdGenSchema: %USDGENSCHEMA_PATH%\necho           Schema: %SCHEMA_PATH%\necho             Dest: %DESTINATION_PATH%\necho.\n\nREM Run the command `hython usdGenSchema 'path/to/schema.usda' 'destination/path'`\n%HYTHON_PATH% %USDGENSCHEMA_PATH% %SCHEMA_PATH% %DESTINATION_PATH%\n\npause\n</code></pre> <p>Note</p> <p>Think about changing your <code>HOUDINI_VERSION</code> and <code>USD_PLUGIN_NAME</code> accordingly.</p> <p>Warning</p> <p><code>%~dp0</code> is the Batch variable that expands to the current directory. Only use it if your .bat file is placed under the plugin folder: <code>usdFxquinox/resources/_run_usdGenSchema.bat</code></p> <p>Let the tool run. Once it\u2019s done, you should have 2 new files:</p> Directory<pre><code>.\n\u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n    \u251c\u2500\u2500 \ud83d\udcc1 resources/\n    \u2502   \u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n    \u2502       \u2514\u2500\u2500 \ud83d\udcc4 schema.usda\n    \u251c\u2500\u2500 \ud83d\udcc4 generatedSchema.usda\n    \u2514\u2500\u2500 \ud83d\udcc4 plugInfo.json\n</code></pre> <p>You\u2019ll need to modify the <code>plugInfo.json</code> file, since usdGenSchema leaves in the cmake <code>@...@</code> string replacements:</p> plugInfo.json<pre><code>...\n    \"LibraryPath\": \"@PLUG_INFO_LIBRARY_PATH@\",\n    \"Name\": \"usdFxquinox\",\n    \"ResourcePath\": \"@PLUG_INFO_RESOURCE_PATH@\",\n    \"Root\": \"@PLUG_INFO_ROOT@\",\n    \"Type\": \"resource\"\n...\n</code></pre> <p>To:</p> plugInfo.json<pre><code>...\n    \"LibraryPath\": \"\",\n    \"Name\": \"usdFxquinox\",\n    \"ResourcePath\": \"resources\",\n    \"Root\": \"..\",\n    \"Type\": \"resource\"\n...\n</code></pre> <p>This change only need to be made once, as indicated in <code>plugInfo.json</code>:</p> plugInfo.json<pre><code># Edits will survive regeneration except for comments and\n# changes to types with autoGenerated=true.\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#edit-environment","title":"Edit Environment","text":"<p>The last step is to add the folder containing <code>plugInfo.json</code> to the <code>PXR_PLUGINPATH_NAME</code> environment variable. In our instance:</p> <pre><code>set PXR_PLUGINPATH_NAME=%SERVER_ROOT%/Projects/Code/fxquinox/plugins/usd/usdFxquinox/resources;%PXR_PLUGINPATH_NAME%\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/","title":"Integrate Custom Schemas","text":"<p>How to integrate a custom USD schema like a native Houdini primitive node.</p> <p>Note</p> <p>You can find the Fxquinox Context Info HDA on GitHub, or start from the Fxquinox Primitive Template HDA there.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#native-node","title":"Native Node","text":"<p>Let\u2019s take a look at the native Render Settings primitive node:</p> <p></p> <p>It contains a couple of important elements:</p> <ul> <li>A Frame Range Sampling menu (useful to get rid of time dependencies)</li> <li>The Primitive Path parm (if in Create Mode)</li> <li>The Primitives parm (if in Edit mode)</li> <li>The Action menu, to either Create or Edit the primitive</li> <li>The Initialize Parameters menu, which lets you batch control the USD parms or retrieve another primitive attribute values (if in Edit mode)</li> <li>The Create Primitives menu, which allows you to control how and where the primitive will be created (if in Create mode)</li> </ul> <p>Warning</p> <p>The Primitive Path only appears in Create mode, whereas the Primitives one appears only in Edit mode. If you push your HDA and requires to use one or the other depending on the selected mode, you can create an invisible parm called <code>prim</code> and feed it a Python expression to retrieve the path(s) from the right parm according to the mode you chose.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#custom-node-hda","title":"Custom Node (HDA)","text":"<p>In order to emulate all those, we can create an HDA with the following structure:</p> Lock Primitive Path <p>Here, Primitive Path is a locked parameter: you might want to add an OnCreated callback to lock it (or simply make the parm invisible) in order to force artists to only use pipeline defined primitive paths.</p> <p></p> <p></p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#internal-nodes","title":"Internal Nodes","text":"","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#error","title":"Error","text":"<p>The Error node contains the following code on the Report this Error parm:</p> Error &gt; enable<pre><code>node = hou.pwd()\nnode_parent = node.parent()\ninputs = node.inputs()\nif inputs and node_parent.evalParm(\"createprims\") == 1:\n    prim = node_parent.evalParm(\"primpath\")\n    stage = inputs[0].stage()\n    return int(stage.GetPrimAtPath(prim).IsValid())\nreturn 0\n</code></pre> <p>It will return this error to the user:</p> <p>An existing `chs(\"hda_label\")` prim has been found at `chs(\"../primpath\")`. You can only have one in your current scene. For selective edits, use a `chs(\"hda_label\")` Edit instead.</p> <p>if another primitive with the same path is found, and you\u2019re about to override it by creating a new one on the same path.</p> <p><code>hda_label</code> is a spare parameter created on the Error node with a Python expression returning the value <code>Fxquinox Context Info</code>:</p> Error &gt; HDA Label<pre><code>parent_node = hou.pwd().parent()\nparent_type = parent_node.type()\nparent_hda_definition = parent_type.definition()\nauthor = parent_type.nameComponents()[1].title()\ndescription = parent_hda_definition.description()\nreturn f\"{author} {description}\"\n</code></pre> <p>Note</p> <p>You can set the message verbosity (error, warning, info) directly onto the node. In this specific instance, we don\u2019t want to allow the creation of multiple Fxquinox Context Info primitives, so it\u2019s set on error, which will effectively set the HDA in an error-state and fail its cooking.</p> <p>For example, Render Settings just throws a warning when you're overriding an existing primitive.</p> <p>Warning</p> <p>Don't forget to add the error node path inside your HDA Type Properties &gt; Node  &gt; Message Nodes so the error gets displayed directly onto the HDA.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#edit-properties-from-node","title":"Edit Properties from Node","text":"<p>This node is where the magic happens. It\u2019s pretty much the same as the Edit Properties node, with a nice change:</p> <p>Quote</p> <p>Instead of adding spare parameters to this node, you must direct it to another node from which it reads parameters that correspond to attributes on prims in the scene graph tree. When you edit these parameters on the other node, this node authors equivalent changes to the equivalent USD attributes.</p> <p>That allows us to add the properties on the HDA itself: they will always be read from it and added accordingly.</p> <p>This node is also linked to the Frame Range Sampling menu, Primitive Path parm, Primitives parm, Action menu, and the Initialize Parameters menu. It\u2019s the one that allows our HDA to behave just like a native node. </p> <p>Tip</p> <p>Basically, promote all parms of this node to your HDA except: Parameters from Node,  Parameters, Prim Local, Prim Path Local, Prim Count Local.</p> <p>Note</p> <p>You can simply drag and drop the Edit Properties from Node node onto the Type Properties window of your HDA to automatically promote all its parameters onto your HDA, then simply delete the ones you don't need.</p> <p>Warning</p> <p>Don't forget to add the Edit Properties from Node node path inside your HDA Type Properties &gt; Node  &gt; Message Nodes so an error gets displayed if the HDA is in Edit mode and it can't find the primitive to edit.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#promote-usd-attributes","title":"Promote USD Attributes","text":"<p>In order for the Edit Properties from Node node to work, we need to bring the USD schema attributes to the HDA interface. With a custom schema, this gets very easy. Open the HDA Type Properties, and inside the Parameters tab navigate to the From USD tab. You can now filter the schema you want and add all its attributes to your parameters.</p> <p></p> <p>They will be automatically read by the Edit Properties from Node node!</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#add-an-edit-alias","title":"Add an Edit Alias","text":"<p>On most of the native nodes creating a primitive, you\u2019ll get two options: the node, and the node edit. Here's what gets displayed when pressing <code>TAB</code> inside the Network View to drop a Render Settings node:</p> <p></p> <p>You have the option to use a regular Render Settings, or a Render Settings Edit. Under the hood, this is a simple tool alias, which sets the Action menu to Edit, and sets all USD parameters to <code>none</code>, effectively bypassing any values that could have been added on the node parameters.</p> <p>Here\u2019s how it\u2019s done for Render Settings (navigate to Render Settings &gt; Type Properties &gt; Interactive &gt; Shelf Tools)</p> <p>Inside the Options tab:</p> <p></p> <p>And inside the Script tab:</p> <p></p> <p>On our custom HDA Type Properties window, inside the Interactive &gt; Shelf Tools tab, we can click on Create New and navigate to the Options tab. Copy-paste the values of the Render Settings &gt; Type Properties &gt; Interactive &gt; Shelf Tools &gt; Options tab.</p> <p>For the Script tab, we need some adjustments:</p> HDA &gt; Type Properties &gt; Interactive &gt; Shelf Tools &gt; Script<pre><code>import loptoolutils, loputils\n\nnode = loptoolutils.genericTool(kwargs, '$HDA_NAME', '$HDA_NAME'.split(\"::\")[1] + '_edit1')\nnode.parm('createprims').set('off')\nloputils.setAllControlParameters(node, 'none')\n</code></pre> <p>As you can see, we need to split the name: <code>$HDA_NAME</code> will return <code>fxquinox::contextinfo</code>, and <code>:</code> is an unauthorized character for a Houdini node name. We simply isolate the second name component, and add the <code>edit_1</code> part to it.</p> <p>Note</p> <p>This is only applicable if your HDA has an author, branch or version namespace.</p> <p>This is what you should end up with inside the Options tab:</p> <p></p> <p>And inside the Script tab:</p> <p></p> <p>You can now try to press <code>TAB</code> inside your Network View to drop the node, and should be welcomed by your HDA and its Edit variant:</p> <p></p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#custom-icon","title":"Custom Icon","text":"<p>You can add an icon in the <code>$HOUDINI_PATH</code> following this naming convention: <code>SCENEGRAPH_primtype_&lt;custom schema class&gt;.svg</code>, to be displayed inside the Houdini Scene Graph Tree every time you apply your custom schema to a primitive:</p> <p> In this case, the icon is <code>SCENEGRAPH_primtype_fxquinoxcontextinfo.svg</code>.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/Render/primitives/","title":"Primitives","text":"<p>How to use the UsdRender primitives in order to output an image.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/primitives/#relationship","title":"Relationship","text":"<p>In USD, all you need to render is a couple of primitives:</p> <ul> <li>RenderSettings</li> <li>RenderProduct</li> <li>RenderVar</li> </ul> <p>Their relationship is described as:</p> <pre><code>erDiagram\n    RenderSettings {\n        relationship products \"/Render/Products/renderproduct\"\n    }\n\n    RenderProduct {\n        relationship orderedVars \"RenderVar A, RenderVar B, RenderVar C\"\n    }\n\n    RenderVarA {\n        string sourceName \"Beauty\"\n    }\n\n    RenderVarB {\n        string sourceName \"CombinedDiffuse\"\n    }\n\n    RenderVarC {\n        string sourceName \"CombinedEmission\"\n    }\n\n    RenderSettings ||--o| RenderProduct: \"produces\"\n    RenderProduct ||--|| RenderVarA : \"consumes\"\n    RenderProduct ||--|| RenderVarB : \"consumes\"\n    RenderProduct ||--|| RenderVarC : \"consumes\"</code></pre> <p>Which translates this way into Houdini Solaris:</p> <p></p> <p>Warning</p> <p>Do not forget to modify the parameter of each primitive: add the RenderVars through Ordered Render Vars inside the RenderProduct, then add the RenderProduct to the RenderSettings through the Ordered Products parameter.</p> <p>Tip</p> <p>As described in Render Globals &gt; Variants, you can order the RenderVars. Taking Arnold as an example, where the Beauty is called RGBA, you'll use <code>/Render/Products/Vars/RGBA /Render/Products/Vars/**</code> inside the RenderProduct Ordered Render Vars parameter to have RGBA prepended to the RenderVars list, so switching to the Arnold Hydra delegate will immediately show the right RenderVar.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/","title":"Render Globals","text":"<p>How to create render globals in USD for use throughout a production.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#goal","title":"Goal","text":"<p>In a production environment, you might want to provide artists with a base of render settings they can use almost anywhere. In Solaris, we can leverage the USD variant system to author a set of variants applied on the <code>/Render</code> primitive to dictate which variant (preset) will be used.</p> <p>Why not appying it directly on the RenderSettings primitive?</p> <p>This allows us to control the linked RenderProducts and RenderVars easily.</p> <p>Ideally, you would publish different global presets for specific pipeline steps: one for lookdev, one for lighting, etc.</p> <p>Note</p> <p>Even when publishing different globals for each pipeline step, they could still inherit from the same \"master\" global containing show resolution, aspect ratio, render engine, etc.</p> <p>We could also have multiple RenderSettings pointing to multiple RenderProducts, but I prefer having a single standardized primitive that always resides in the same location \u2014 it simplifies things.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#setup","title":"Setup","text":"<p>In Solaris, the setup would look like this: </p> <p></p> <p>You can see two \"main\" variant branches: beauty and technical. This is a personal production choice, where a technical pass contains the same renderable objects as the beauty pass but without lighting, a very low sample count, and what's defined as technical RenderVars: depth, P, N, etc.  You could add many more, e.g. a branch for environment, another one for characters, etc.</p> <p>Let's now dive deeper into each section of the above graph.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#rendervars-aovs","title":"RenderVars (AOVs)","text":"<p>Here's the RenderVars part of the setup, where we define our RenderVar primitives:</p> <p></p> <p>Each Karma Standard Render Vars node defines RenderVars for both the beauty and technical branches.</p> <p>The trick is in the Configure Primitive and Edit Properties nodes: We select the newly created RenderVar primitives and apply a custom API schemato them. This adds a new set of attributes to the primitives, in my case a single <code>beacon:renderVarType</code> token, which can be set to beauty, technical, light, crypto, or extra.</p> <p>Why do we do this? </p> <p>Adding an extra attribute to the RenderVar primitives allows you to group them neatly. In Houdini, you can then use a primitive pattern to select only the ones you want: <code>/Render/Products/Vars/** &amp; %type(RenderVar) &amp; {usd_attrib(0, @primpath, \"beacon:renderVarType\") == \"beauty\"}</code> will only iterate over the RenderVars you have defined as beauty RenderVars.</p> schema.usda<pre><code>class \"BeaconRenderVarAPI\" (\n    customData = {\n        string[] apiSchemaCanOnlyApplyTo = [\"RenderVar\"]\n        string className = \"RenderVarAPI\"\n    }\n    inherits = &lt;/APISchemaBase&gt;\n)\n{\n    token beacon:renderVarType (\n        doc = \"\"\"Indicates the type of the RenderVar.\n\n        - \"beauty\": Beauty AOVs, used to build the beauty pass back in a compositing software.\n        - \"technical\":  Technical AOVs, usually used on utility passes.\n        - \"light\":  AOVs generated through LPEs (Light Path Expression).\n        - \"crypto\":  AOVs for CryptoMatte.\n        - \"extra\": Additional debugging and miscelleanous AOVs.\n        \"\"\"\n        allowedTokens = [\"beauty\", \"technical\", \"light\", \"crypto\", \"extra\"]\n    )\n}\n</code></pre> <p>Note</p> <p>You don't need to add a custom API schema; a simple Edit Properties node where you add a token parameter will suffice. I created the API schema since it's faster to reuse and less prone to human error.</p> <p>Alternative</p> <p>An even simpler way is to group the RenderVar primitives under a new Scope primitive for each \"group\". Note that this might require more work in the long run as some render engines expect RenderVars to be under <code>/Render/Product/Vars</code> by default. </p> <p>I also find there are some benefits in having an attribute that can be read directly from the primitive rather than having to look for its parent.</p> <p></p> <p>If you're choosing that method, think about changing the primitive patterns in the variants section of this guide.</p> <p>Here are the node parameters for the technical side:</p> <p></p> <p></p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#base","title":"Base","text":"<p>Now, define your main RenderProduct and RenderSettings:</p> <p></p> <p>Here, you define the main settings from which we'll branch out for our variants: resolution, samples, etc.</p> <p>Note</p> <p>Notice how we add all RenderVars to the RenderProduct? You can do this or not; it doesn't really matter since we'll refine the selection for each variant.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#variants","title":"Variants","text":"<p>Now we set up the variants for each render preset we want.</p> <p></p> <p>We'll work from the beauty (left on the above graph) branch.</p> <p>Start with the Configure Primitive nodes: each node deactivates the RenderVars we don't want in a branch. This provides visual feedback when looking at the Scene Graph Tree, showing which ones will be added to the RenderProduct and which won't:</p> <p></p> <p>Tip</p> <p>Deactivating primitives also allows you to filter them later using a primitive pattern: <code>/Render/Products/Vars/** &amp; %type(RenderVar) &amp; {usd_isactive(0, @primpath)}</code> will only iterate over activated RenderVar primitives.</p> <p>It's also a good way to squeeze some performance as deactivated primitives are \"off-limits\" for the render engine.</p> <p>Warning</p> <p>If you used the alternative method in the RenderVars (AOVs) section, the primitive pattern should be <code>/Render/Products/Vars/Technical/** &amp; %type(RenderVar)</code>.</p> <p>Note</p> <p>You can also enable Hide Primitive In Scene Graph to hide them altogether.</p> <p>Then, edit the RenderProduct primitive added in the base section with a Render Product Edit node, adding only the RenderProducts we want for the selected branch:</p> <p></p> <p>Warning</p> <p>If you used the alternative method in the RenderVars (AOVs) section, the primitive pattern should be <code>/Render/Products/Vars/Beauty/** &amp; %type(RenderVar)</code>.</p> <p>Tip</p> <p>You'll notice some repetition in the primitive pattern: <code>/Render/Products/Vars/Beauty /Render/Products/Vars/**</code>. Since RenderVars are added alphabetically, you want Beauty to come first, not something like Albedo or AO. Otherwise, the Scene Viewer will show the wrong RenderVar first when switching to another Hydra delegate than Houdini GL (or VK).</p> <p>Now, create your Render Settings Edit node and start editing the render engine settings based on the presets you want. In my setup, I have BTY_high, BTY_mid, and BTY_low. Each is connected to the previous one, but that's not mandatory: I'm doing it to easily divide the attribute values coming from the high quality variant into the lower quality ones.</p> <p>Once you have your presets saved, plug them into the Add Variant second input, set the variant set and variant names, and voila!</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#final","title":"Final","text":"<p>If everything went well, the <code>/Render</code> primitive should now have several new variants (it should be green in the Scene Graph Tree).</p> <p>To check that everything worked, drop a new Set Variant node and flick through your variants. Here's the BTY_high variant:</p> <p></p> <p>And the UTL_high variant:</p> <p></p> <p>Notice how the RenderVars primitives get disabled based on the variant choice? That's a good sign your variants are ready. You should also check your RenderSettings and RenderProduct attributes to ensure everything went well.</p> <p>Once you're done, export the graph as a USD file and import it back as a Sublayer.</p> <p>Tip</p> <p>You might want to add the USD sublayer fairly high in the graph so you can edit its properties. If you use it in a shot environment, you may need to specify a camera using a Render Settings Edit node, which will need to point to an existing RenderSettings primitive.</p> <p>Primitive Patterns</p> <p>You might notice I'm using <code>**</code> in some primitive patterns throughout this guide, even though a simple <code>*</code> would suffice. This is a precaution in case an artist creates the RenderVars within another nested primitive under the <code>/Render/Products/Vars</code> primitive.</p> <p>This pattern isn\u2019t resource-intensive, as only RenderVar primitives are expected to reside in that location.</p> <p>Resources</p> <p>The asset used in the above screenshots is Golden Knight by Francis Lamoureux, downloaded from Sketchfab.</p> <p>Backlinks:</p>","tags":["houdini","usd","render"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#development","title":"development","text":"<ul> <li>Auto Changelog</li> <li>Distribute Package to PyPi</li> <li>Multiple Versions on Windows</li> <li>Multiple Versions on macOS</li> </ul>"},{"location":"tags/#home","title":"home","text":"<ul> <li>Home</li> </ul>"},{"location":"tags/#houdini","title":"houdini","text":"<ul> <li>Custom Schemas</li> <li>Integrate Custom Schemas</li> <li>Primitives</li> <li>Render Globals</li> </ul>"},{"location":"tags/#javascript","title":"javascript","text":"<ul> <li>Auto Changelog</li> </ul>"},{"location":"tags/#macos","title":"macOS","text":"<ul> <li>Multiple Versions on macOS</li> </ul>"},{"location":"tags/#package","title":"package","text":"<ul> <li>Auto Changelog</li> <li>Distribute Package to PyPi</li> </ul>"},{"location":"tags/#plugin","title":"plugin","text":"<ul> <li>Custom Schemas</li> <li>Integrate Custom Schemas</li> </ul>"},{"location":"tags/#python","title":"python","text":"<ul> <li>Auto Changelog</li> <li>Distribute Package to PyPi</li> <li>Multiple Versions on Windows</li> <li>Multiple Versions on macOS</li> </ul>"},{"location":"tags/#render","title":"render","text":"<ul> <li>Primitives</li> <li>Render Globals</li> </ul>"},{"location":"tags/#usd","title":"usd","text":"<ul> <li>Custom Schemas</li> <li>Integrate Custom Schemas</li> <li>Primitives</li> <li>Render Globals</li> </ul>"},{"location":"tags/#windows","title":"windows","text":"<ul> <li>Multiple Versions on Windows</li> </ul>"}]}