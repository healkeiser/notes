{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"","tags":["home"]},{"location":"#notes","title":"Notes","text":"<p>This documentation is built with MkDocs and the MkDocs Publisher plugin, since I'm using Obsidian to take the notes. You can clone the repository and open it as an Obsidian Vault if you prefer reading it locally!</p> <p>Warning</p> <p>Some stuff might get displayed incorrectly in Obsidian, such as HTML tags.</p> <p>Warning</p> <p>You might notice a lot of <code>README.md</code> files, please ignore those - they're here to indicate attributes on directories for MkDocs Publisher.</p> <p>Note</p> <p>If you spot any issue or have any recommendations, don't hesitate to send me an email.</p>","tags":["home"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/","title":"Custom Schemas","text":"<p>How-to create a USD custom schema.</p> <p>Important Links</p> <ul> <li> <p>USD Survival Guide - Schemas</p> </li> <li> <p>USD - Generating New Schema Classes</p> </li> </ul> <p>Note</p> <p>You can find the usdFxquinox plugin on GitHub.</p> <p>The easiest way to create a custom schema is to create what\u2019s called a codeless schema (uncompiled version). This will create a new schema but won\u2019t provide the C++/Python bindings from the freshly created schema class.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#directory-structure","title":"Directory Structure","text":"<p>Let\u2019s start by creating a directory and a <code>schema.usda</code> file:</p> <pre><code>.\n\u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n    \u2514\u2500\u2500 \ud83d\udcc1 resources/\n        \u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n            \u2514\u2500\u2500 \ud83d\udcc4schema.usda\n</code></pre> <p>Which corresponds to:</p> <pre><code>.\n\u2514\u2500\u2500 \ud83d\udcc1 &lt;plugin name&gt;/\n    \u2514\u2500\u2500 \ud83d\udcc1 resources/\n        \u2514\u2500\u2500 \ud83d\udcc1 &lt;plugin name&gt;/\n            \u2514\u2500\u2500 \ud83d\udcc4 schema.usda\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#edit-schemausda","title":"Edit <code>schema.usda</code>","text":"<p>Let\u2019s now edit our <code>schema.usda</code> file. This will contain the IsA schemas or API schemas you want to create.</p> schema.usda<pre><code>#usda 1.0\n(\n    subLayers = [\n        @usd/schema.usda@\n    ]\n)\n\nover \"GLOBAL\" (\n    customData = {\n        string libraryName       = \"usdFxquinox\"\n        string libraryPath       = \".\"\n        string libraryPrefix     = \"usdFxquinox\"\n        bool skipCodeGeneration = true\n    }\n)\n{\n}\n\nclass FxquinoxContextInfo \"FxquinoxContextInfo\" (\n    doc = \"\"\"Holder for fxquinox-specific context information.\"\"\"\n    inherits = &lt;/Typed&gt;\n    customData = {\n        string className = \"ContextInfo\"\n        }\n    )\n{\n    string fxquinox:project (\n        doc = \"\"\"The project name.\"\"\"\n    )\n\n    asset fxquinox:projectRoot (\n        doc = \"\"\"The project root path.\"\"\"\n    )\n\n    string fxquinox:entity (\n        doc = \"\"\"The current context entity (asset or shot).\"\"\"\n    )\n\n    string fxquinox:assetType (\n        doc = \"\"\"If the entity is an asset, the type of asset.\"\"\"\n    )\n\n    string fxquinox:asset (\n        doc = \"\"\"If the entity is an asset, the asset.\"\"\"\n    )\n\n    string fxquinox:sequence (\n        doc = \"\"\"If the entity is a shot, the sequence.\"\"\"\n    )\n\n    string fxquinox:shot (\n        doc = \"\"\"If the entity is a shot, the shot.\"\"\"\n    )\n\n    string fxquinox:step (\n        doc = \"\"\"The context pipeline step.\"\"\"\n    )\n\n    string fxquinox:task (\n        doc = \"\"\"The context pipeline task.\"\"\"\n    )\n\n    string fxquinox:user (\n        doc = \"\"\"The current username.\"\"\"\n    )\n\n    string fxquinox:hostname (\n        doc = \"\"\"The current hostname (machine name).\"\"\"\n    )\n}\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#run-usdgenschema","title":"Run usdGenSchema","text":"<p>Once you\u2019re happy with your new schema, we now need to run usdGenSchema. The easiest way is to run the one shipping with your DCC compiled USD.</p> <p>I made this batch script to run it on Windows:</p> .run_usdGenSchema.bat<pre><code>@echo off\n\nREM Set paths to Houdini programs, and the USD file\nset HOUDINI_VERSION=20.0.547\nset USD_PLUGIN_NAME=usdFxquinox\nset HYTHON_PATH=\"C:\\Program Files\\Side Effects Software\\Houdini %HOUDINI_VERSION%\\bin\\hython.exe\"\nset USDGENSCHEMA_PATH=\"C:\\Program Files\\Side Effects Software\\Houdini %HOUDINI_VERSION%\\bin\\usdGenSchema\"\nset SCHEMA_PATH=%~dp0%USD_PLUGIN_NAME%\\schema.usda\nset DESTINATION_PATH=%~dp0\n\necho Running usdGenSchema for %USD_PLUGIN_NAME%:\necho           Hython: %HYTHON_PATH%\necho       USD plugin: %USD_PLUGIN_NAME%\necho     UsdGenSchema: %USDGENSCHEMA_PATH%\necho           Schema: %SCHEMA_PATH%\necho             Dest: %DESTINATION_PATH%\necho.\n\nREM Run the command `hython usdGenSchema 'path/to/schema.usda' 'destination/path'`\n%HYTHON_PATH% %USDGENSCHEMA_PATH% %SCHEMA_PATH% %DESTINATION_PATH%\n\npause\n</code></pre> <p>Note</p> <p>Think about changing your <code>HOUDINI_VERSION</code> and <code>USD_PLUGIN_NAME</code> accordingly.</p> <p>Warning</p> <p><code>%~dp0</code> is the Batch variable that expands to the current directory. Only use it if your .bat file is placed under the plugin folder: <code>usdFxquinox/resources/_run_usdGenSchema.bat</code></p> <p>Let the tool run. Once it\u2019s done, you should have 2 new files:</p> <pre><code>.\n\u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n    \u251c\u2500\u2500 \ud83d\udcc1 resources/\n    \u2502   \u2514\u2500\u2500 \ud83d\udcc1 usdFxquinox/\n    \u2502       \u2514\u2500\u2500 \ud83d\udcc4 schema.usda\n    \u251c\u2500\u2500 \ud83d\udcc4 generatedSchema.usda\n    \u2514\u2500\u2500 \ud83d\udcc4 plugInfo.json\n</code></pre> <p>You\u2019ll need to modify the <code>plugInfo.json</code> file, since usdGenSchema leaves in the cmake <code>@...@</code> string replacements:</p> plugInfo.json<pre><code>...\n    \"LibraryPath\": \"@PLUG_INFO_LIBRARY_PATH@\",\n    \"Name\": \"usdFxquinox\",\n    \"ResourcePath\": \"@PLUG_INFO_RESOURCE_PATH@\",\n    \"Root\": \"@PLUG_INFO_ROOT@\",\n    \"Type\": \"resource\"\n...\n</code></pre> <p>To:</p> plugInfo.json<pre><code>...\n    \"LibraryPath\": \"\",\n    \"Name\": \"usdFxquinox\",\n    \"ResourcePath\": \"resources\",\n    \"Root\": \"..\",\n    \"Type\": \"resource\"\n...\n</code></pre> <p>This change only need to be made once, as indicated in <code>plugInfo.json</code>:</p> <pre><code># Edits will survive regeneration except for comments and\n# changes to types with autoGenerated=true.\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/custom-schemas/#edit-environment","title":"Edit Environment","text":"<p>The last step is to add the folder containing <code>plugInfo.json</code> to the <code>PXR_PLUGINPATH_NAME</code> environment variable. In our instance:</p> <pre><code>set PXR_PLUGINPATH_NAME=%SERVER_ROOT%/Projects/Code/fxquinox/plugins/usd/usdFxquinox/resources;%PXR_PLUGINPATH_NAME%\n</code></pre>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/","title":"Integrate Custom Schemas","text":"<p>How to integrate a custom USD schema like a native Houdini primitive node.</p> <p>Note</p> <p>You can find the Fxquinox Context Info HDA on GitHub, or start from the Fxquinox Primitive Template HDA there.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#native-node","title":"Native Node","text":"<p>Let\u2019s take a look at the native Render Settings primitive node:</p> <p></p> <p>It contains a couple of important elements:</p> <ul> <li>A Frame Range Sampling menu (useful to get rid of time dependencies)</li> <li>The Primitive Path parm (if in Create Mode)</li> <li>The Primitives parm (if in Edit mode)</li> <li>The Action menu, to either Create or Edit the primitive</li> <li>The Initialize Parameters menu, which lets you batch control the USD parms or retrieve another primitive attribute values (if in Edit mode)</li> <li>The Create Primitives menu, which allows you to control how and where the primitive will be created (if in Create mode)</li> </ul> <p>Warning</p> <p>The Primitive Path only appears in Create mode, whereas the Primitives one appears only in Edit mode. If you push your HDA and requires to use one or the other depending on the selected mode, you can create an invisible parm called <code>prim</code> and feed it a Python expression to retrieve the path(s) from the right parm according to the mode you chose.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#custom-node-hda","title":"Custom Node (HDA)","text":"<p>In order to emulate all those, we can create an HDA with the following structure:</p> Lock Primitive Path <p>Here, Primitive Path is a locked parameter: you might want to add an OnCreated callback to lock it (or simply make the parm invisible) in order to force artists to only use pipeline defined primitive paths.</p> <p></p> <p></p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#internal-nodes","title":"Internal Nodes","text":"","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#error","title":"Error","text":"<p>The Error node contains the following code on the Report this Error parm:</p> Error &gt; enable<pre><code>node = hou.pwd()\nnode_parent = node.parent()\ninputs = node.inputs()\nif inputs and node_parent.evalParm(\"createprims\") == 1:\n    prim = node_parent.evalParm(\"primpath\")\n    stage = inputs[0].stage()\n    return int(stage.GetPrimAtPath(prim).IsValid())\nreturn 0\n</code></pre> <p>It will return this error to the user:</p> <p>An existing `chs(\"hda_label\")` prim has been found at `chs(\"../primpath\")`. You can only have one in your current scene. For selective edits, use a `chs(\"hda_label\")` Edit instead.</p> <p>if another primitive with the same path is found, and you\u2019re about to override it by creating a new one on the same path.</p> <p><code>hda_label</code> is a spare parameter created on the Error node with a Python expression returning the value <code>Fxquinox Context Info</code>:</p> Error &gt; HDA Label<pre><code>parent_node = hou.pwd().parent()\nparent_type = parent_node.type()\nparent_hda_definition = parent_type.definition()\nauthor = parent_type.nameComponents()[1].title()\ndescription = parent_hda_definition.description()\nreturn f\"{author} {description}\"\n</code></pre> <p>Note</p> <p>You can set the message verbosity (error, warning, info) directly onto the node. In this specific instance, we don\u2019t want to allow the creation of multiple Fxquinox Context Info primitives, so it\u2019s set on error, which will effectively set the HDA in an error-state and fail its cooking.</p> <p>For example, Render Settings just throws a warning when you're overriding an existing primitive.</p> <p>Warning</p> <p>Don't forget to add the error node path inside your HDA Type Properties &gt; Node  &gt; Message Nodes so the error gets displayed directly onto the HDA.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#edit-properties-from-node","title":"Edit Properties from Node","text":"<p>This node is where the magic happens. It\u2019s pretty much the same as the Edit Properties node, with a nice change:</p> <p>Quote</p> <p>Instead of adding spare parameters to this node, you must direct it to another node from which it reads parameters that correspond to attributes on prims in the scene graph tree. When you edit these parameters on the other node, this node authors equivalent changes to the equivalent USD attributes.</p> <p>That allows us to add the properties on the HDA itself: they will always be read from it and added accordingly.</p> <p>This node is also linked to the Frame Range Sampling menu, Primitive Path parm, Primitives parm, Action menu, and the Initialize Parameters menu. It\u2019s the one that allows our HDA to behave just like a native node. </p> <p>Tip</p> <p>Basically, promote all parms of this node to your HDA except: Parameters from Node,  Parameters, Prim Local, Prim Path Local, Prim Count Local.</p> <p>Note</p> <p>You can simply drag and drop the Edit Properties from Node node onto the Type Properties window of your HDA to automatically promote all its parameters onto your HDA, then simply delete the ones you don't need.</p> <p>Warning</p> <p>Don't forget to add the Edit Properties from Node node path inside your HDA Type Properties &gt; Node  &gt; Message Nodes so an error gets displayed if the HDA is in Edit mode and it can't find the primitive to edit.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#promote-usd-attributes","title":"Promote USD Attributes","text":"<p>In order for the Edit Properties from Node node to work, we need to bring the USD schema attributes to the HDA interface. With a custom schema, this gets very easy. Open the HDA Type Properties, and inside the Parameters tab navigate to the From USD tab. You can now filter the schema you want and add all its attributes to your parameters.</p> <p></p> <p>They will be automatically read by the Edit Properties from Node node!</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#add-an-edit-alias","title":"Add an Edit Alias","text":"<p>On most of the native nodes creating a primitive, you\u2019ll get two options: the node, and the node edit. Here's what gets displayed when pressing <code>TAB</code> inside the Network View to drop a Render Settings node:</p> <p></p> <p>You have the option to use a regular Render Settings, or a Render Settings Edit. Under the hood, this is a simple tool alias, which sets the Action menu to Edit, and sets all USD parameters to <code>none</code>, effectively bypassing any values that could have been added on the node parameters.</p> <p>Here\u2019s how it\u2019s done for Render Settings (navigate to Render Settings &gt; Type Properties &gt; Interactive &gt; Shelf Tools)</p> <p>Inside the Options tab:</p> <p></p> <p>And inside the Script tab:</p> <p></p> <p>On our custom HDA Type Properties window, inside the Interactive &gt; Shelf Tools tab, we can click on Create New and navigate to the Options tab. Copy-paste the values of the Render Settings &gt; Type Properties &gt; Interactive &gt; Shelf Tools &gt; Options tab.</p> <p>For the Script tab, we need some adjustments:</p> HDA &gt; Type Properties &gt; Interactive &gt; Shelf Tools &gt; Script<pre><code>import loptoolutils, loputils\n\nnode = loptoolutils.genericTool(kwargs, '$HDA_NAME', '$HDA_NAME'.split(\"::\")[1] + '_edit1')\nnode.parm('createprims').set('off')\nloputils.setAllControlParameters(node, 'none')\n</code></pre> <p>As you can see, we need to split the name: <code>$HDA_NAME</code> will return <code>fxquinox::contextinfo</code>, and <code>:</code> is an unauthorized character for a Houdini node name. We simply isolate the second name component, and add the <code>edit_1</code> part to it.</p> <p>Note</p> <p>This is only applicable if your HDA has an author, branch or version namespace.</p> <p>This is what you should end up with inside the Options tab:</p> <p></p> <p>And inside the Script tab:</p> <p></p> <p>You can now try to press <code>TAB</code> inside your Network View to drop the node, and should be welcomed by your HDA and its Edit variant:</p> <p></p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/plugins/integrate-custom-schemas/#custom-icon","title":"Custom Icon","text":"<p>You can add an icon in the <code>$HOUDINI_PATH</code> following this naming convention: <code>SCENEGRAPH_primtype_&lt;custom schema class&gt;.svg</code>, to be displayed inside the Houdini Scene Graph Tree every time you apply your custom schema to a primitive:</p> <p> In this case, the icon is <code>SCENEGRAPH_primtype_fxquinoxcontextinfo.svg</code>.</p>","tags":["houdini","usd","plugin"]},{"location":"softwares/houdini/usd/Render/render-globals/","title":"Render Globals","text":"<p>How to create render globals in USD, to use throughout a production.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#goal","title":"Goal","text":"<p>In a production environment, you might want to give artists a base of render settings they can use pretty much anywhere. In Solaris, we can take advantage of the variant system, and publish a set of variants applied on the <code>/Render</code> primitive to dictate which variant (preset) will be used.</p> <p>Ideally, you'd publish different global presets against a specific pipeline step: one for lookdev, one for lighting, etc. </p> <p>Note</p> <p>Even with publishing different globals against their own pipeline step, they could still inherit from the same \"master\" global which could contain show resolution, aspect ratio, render engine, etc.</p> <p>We could also have have multiple RenderSettings pointing to multiple RenderProducts, but I like the idea of having a standardized primitive for a specific task.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#setup","title":"Setup","text":"<p>In Solaris, the setup would look like this: </p> <p> You can see there are two \"main\" variant branches: beauty and technical. This is a personal production choice, where a technical pass would contain the same renderable objects as the beauty pass, but without lighting, a very low sample count and what's defined as technical AOVs: depth, P, N, etc.</p> <p>Let's now dive into deeper into each section of the above graph:</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#aovs","title":"AOVs","text":"<p>Here's the AOV part of the setup, where we define our RenderVar primitives:</p> <p></p> <p>Each Karma Standard Render Vars define AOVs for both the beauty and technical branch. The trick is found in the Configure Primitive and Edit Properties nodes: We select the freshy created AOVs, and we apply a custom API schemato them. This adds a new set of attributes on the primitives, in this instance a beacon:renderVarType token, which can be set on beauty, technical, light, crypto and extra.</p> <p>Question</p> <p>Why the hell do we do this? Well, appplying an extra attribute to the RenderVar primitives allows you to group them neatly. In Houdini, you can then use a primitive pattern to only select the ones you want: <code>/Render/Products/Vars/* &amp; %type(RenderVar) &amp; {usd_attrib(0, @primpath, \"beacon:renderVarType\") == \"beauty\"}</code> will only iterate over the RenderVars you have defined as beauty AOVs.</p> <p>Note</p> <p>You don't need to add a custom API schema, a simple Edit Properties on which you add a token parameter will be enough. I created the API schema since it's faster to re-use and less prone to human error.</p> <p>Here's what the node parameters look like for the technical side:</p> <p></p> <p></p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#base","title":"Base","text":"<p>We can now define our main RenderProduct and RenderSettings:</p> <p></p> <p>You'll define here the main settings, from which we'll then branch out for our variants: resolution, samples, etc.</p> <p>Note</p> <p>Notice how add all RenderVars to the RenderProduct? You can do it or not, it doesn't really matter as we'll refine the AOV selection for each variant.</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#variants","title":"Variants","text":"<p>Here comes the heavy part: setting up the variants for each render preset we want.</p> <p></p> <p>We'll be working from the beauty branch for the following.</p> <p>Let's start by the Configure Primitive nodes: each takes the AOVs that we don't want in a branch, and deactivate them. This is a neat way to have a visual feedback when looking at the Scene Graph Tree that some AOVs will be added to the RenderProduct, and others won't:</p> <p></p> <p>Tip</p> <p>Deactivating primitives also gives you the ability to filter them later on using a primitive pattern: <code>/Render/Products/Vars/** &amp; {usd_isactive(0, @primpath)}</code> will only iterate over activated RenderVar primitives.</p> <p>Note</p> <p>You can also enable the Hide Primitive In Scene Graph tree to hide them altogether.</p> <p>We then edit the RenderProduct primitive added in the base section with a Render Product Edit node, adding only the AOVs we want for the selected branch:</p> <p></p> <p>Tip</p> <p>You'll notice that we have some sort of a repetition in the primitive pattern: <code>/Render/Products/Vars/Beauty /Render/Products/Vars/**</code>. Since RenderVars are added by alphabetical order, you want the Beauty to come first, and not something like Albedo or AO. Otherwise, the Scene Viewer will show the wrong AOV first when switching to another Hydra delegate than Houdini GL (or VK).</p> <p>We can now create our Render Settings Edit, and start editing the render engine settings based on the presets you want. In my setup, I have BTY_high, BTY_mid and BTY_low. You can see that each of them are connected to the previous one, that is not mandatory: I'm doing it so I can simply divide the attribute values of the high variant into the lower-quality ones.</p> <p>Once you have your presets saved, simply plug them inside the Add Variant second input, set the variant set and variant names, and voila!</p>","tags":["houdini","usd","render"]},{"location":"softwares/houdini/usd/Render/render-globals/#final","title":"Final","text":"<p>If everything went well, the <code>/Render</code> primitive now comes with a bunch of new variants (it should be green in the Scene Graph Tree).</p> <p>To check that everything worked, drop a new Set Variant node and flick through your variants. Here's the BTY_high variant:</p> <p></p> <p>And the UTL_high one:</p> <p></p> <p>Notice how the RenderVars primitives get disabled based on the the variant choice? That's a good sign that your variants are ready. You should also check your RenderSettings and RenderProduct primitive attributes to see if everything went well.</p> <p>Once you're done, simply export the graph as a USD file, and use import it back as a Sublayer.</p> <p>Tip</p> <p>You might want to add the USD sublayer fairly high in the graph, so you can edit its properties: if you use it in a shot environment, you will maybe need to specify a camera using a Render Settings Edit node, which will need to point to an existing RenderSettings primitive.</p> <p>Resources</p> <p>The asset used in the above screenshots is Golden Knight from Francis Lamoureux, downloaded on Sketchfab.</p>","tags":["houdini","usd","render"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#home","title":"home","text":"<ul> <li>Home</li> </ul>"},{"location":"tags/#houdini","title":"houdini","text":"<ul> <li>Custom Schemas</li> <li>Integrate Custom Schemas</li> <li>Render Globals</li> </ul>"},{"location":"tags/#plugin","title":"plugin","text":"<ul> <li>Custom Schemas</li> <li>Integrate Custom Schemas</li> </ul>"},{"location":"tags/#render","title":"render","text":"<ul> <li>Render Globals</li> </ul>"},{"location":"tags/#usd","title":"usd","text":"<ul> <li>Custom Schemas</li> <li>Integrate Custom Schemas</li> <li>Render Globals</li> </ul>"}]}